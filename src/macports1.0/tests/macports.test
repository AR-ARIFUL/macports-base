package require tcltest 2
namespace import tcltest::*

set pwd [file normalize $argv0]
set pwd [eval file join {*}[lrange [file split $pwd] 0 end-1]]

package require macports 1.0
mportinit

source ../macports.tcl


test ui_isset {
    Ui is set unit test.
} -body {
    namespace eval macports {
	array set ui_options { test yes }
    }
    if {[macports::ui_isset test] != 1} {
	return "FAIL: set option not detected"
    }
    if {[macports::ui_isset port] != 0} {
	return "FAIL: unset option detected"
    }
    return "ui_isset successful."
} -result "ui_isset successful."


test global_option_isset {
    Global option is set unit test.
} -body {
    namespace eval macports {
	array set global_options { test yes }
    }
    if {[macports::global_option_isset test] != 1} {
	return "FAIL: set option not detected"
    }
    if {[macports::global_option_isset port] != 0} {
	return "FAIL: unset option detected"
    }
    return "Global option isset successful."
} -result "Global option isset successful."


test init_logging {
    Init logging unit test.
} -constraints {
    root
} -body {
    set mport [mportopen file://.]
    if {[macports::init_logging $mport] != 0} {
	return "FAIL: incorrect channels"
    }
    if {$macports::channels(any) != "stdout debuglog"} {
	return "FAIL: incorrect channels(any)"
    }
    if {$macports::channels(debug) != "debuglog"} {
	return "FAIL: incorrect channels(debug)"
    }
    mportclose $mport
    return "Init logging successful."
} -result "Init logging successful."


test ch_logging {
    Channel logging unit test. Assumes main.log filename.
} -constraints {
    root
} -setup {
    set mport [mportopen file://.]

    set portname [_mportkey $mport subport]
    set portpath [_mportkey $mport portpath]
    set logname [macports::getportlogpath $portpath $portname]
    file delete -force $logname

} -body {
    if {[macports::ch_logging $mport] != 0} {
	return "FAIL: channels not set"
    }
    if {![file exists $logname]} {
	return "FAIL: logname dir missing"
    }
    if {![file exists $logname/main.log]} {
	return "FAIL: main.log missing"
    }
    return "Channel logging successful."

} -cleanup {
    mportclose $mport
} -result "Channel logging successful."


test push_log {
    Push log unit test.
} -constraints {
    root
} -body {
    set mport [mportopen file://.]

    set ::logenabled 1
    if {[catch {macports::push_log $mport}] != 0} {
	return "FAIL: cannot push log"
    }
    if {[lindex $::logstack 0] != [list $::debuglog $::debuglogname]} {
	return "FAIL: incorrect logstack"
    }
    mportclose $mport
    return "Push log successful."
} -result "Push log successful."


# test pop_log
# test set_phase
# test ui_message
# test ui_init
# test ui_prefix_default
# test ui_channels_default
# test ui_warn_once
# test puts


test findBinary {
    Find binary unit test.
} -body {
    if {[macports::findBinary pwd ls] != "/bin/pwd"} {
	return "FAIL: wrong binary"
    }
    if {[macports::findBinary pwd /bin/ls] != "/bin/ls"} {
	return "FAIL: wrong binary"
    }
    return "Find binary successful."
} -result "Find binary successful."


test binaryInPath {
    Binary in path unit test.
} -body {
    if {[catch {macports::binaryInPath zz}] != 1} {
	return "FAIL: invalid binary found"
    }
    if {[macports::binaryInPath ls] != "/bin/ls"} {
	return "FAIL: wrong binary found"
    }
    return "Binary in path successful."
} -result "Binary in path successful."


# test getoption


test setxcodeinfo {
    Set XCode info unit test.
} -constraints {
    root
} -body {
    unset macports::xcodeversion

    if {[macports::setxcodeinfo a b c] != ""} {
	return "FAIL: xcode binary not found"
    }
    if {![info exists macports::xcodeversion]} {
	return "FAIL: xcodeversion unset"
    }
    return "Set XCode version successful."
} -result "Set XCode version successful."


test set_developer_dir {
    Set developer dir unit test. Tests only for correct xcode-select dir.
} -constraints {
    root
} -body {
    unset macports::developer_dir

    if {[macports::set_developer_dir a b c] != ""} {
	return "FAIL: cannot set dev dir"
    }
    if {![info exists macports::developer_dir]} {
	return "FAIL: developer_dir var no set"
    }
    return "Set developer dir successful."
} -result "Set developer dir successful."


test _is_valid_developer_dir {
    Check valid dev dir unit test.
} -body {
    set macports::set_developer /Applications/Xcode.app/Contents/Developer
    if {[macports::_is_valid_developer_dir $macports::developer_dir] != 1} {
	return "FAIL: valid dir not detected"
    }
    return "Valid dev dir successful."
} -result "Valid dev dir successful."


test mportinit {
    Mport init unit test.
} -body {
    #puts [mportinit]
} -result ""


test mportshutdown {
    Mport shutdown unit test.
} -setup {
    unset macports::ping_cache

    set time [expr [clock seconds] - 86100]
    set time_exp [expr [clock seconds] - 87000]
    set macports::portdbpath $pwd/portdbpath
    set macports::ping_cache(host1) [list test $time]
    set macports::ping_cache(host2) [list test $time_exp]

    file mkdir $macports::portdbpath
    close [open $macports::portdbpath/pingtimes w+]
} -body {
    if {[mportshutdown] != ""} {
	return "FAIL: errors occured"
    }

    set res ""
    append res "host1 \{test " $time "\}"
    set fd [open $macports::portdbpath/pingtimes r]

    if {[gets $fd] != $res} {
	return "FAIL: wrong value saved"
    }
    close $fd
    return "Mportshutdown successful."

} -cleanup {
    file delete -force $macports::portdbpath
} -result "Mportshutdown successful."


test copy_xcode_plist {
    Copy xcode plist unit test.
} -constraints {
    root
} -body {
    set target $pwd/target

    if {[macports::copy_xcode_plist $target] != ""} {
	return "FAIL: cannot copy xcode plist"
    }
    if {![file exists $target/Library/Preferences/com.apple.dt.Xcode.plist]} {
	return "FAIL: missing plist file"
    }
    return "Copy xcode plist successful."
    puts $res
} -cleanup {
    file delete -force $target
} -result "Copy xcode plist successful."


test worker_init {
    Worker init unit test.
} -setup {
    set name [interp create]
    set portpath $pwd/portpath
    set porturl http://www.macports.org
    set portbuildpath $pwd/build
    set options {a b}
    set variations {1 2}
} -body {
    macports::worker_init $name $portpath $porturl $portbuildpath $options $variations
    if {$name != "interp0"} {
	return "FAIL: wrong workername"
    }
    if {[$name eval source Portfile] != "yes"} {
	return "FAIL: cannot load Portfile"
    }
    if {[$name eval findBinary ls] != "/bin/ls"} {
	return "FAIL: alias not created"
    }
    if {[$name eval return \$os_arch] != "i386"} {
	return "FAIL: var not set"
    }
    return "Worker init successful."
} -result "Worker init successful."


test crate_thread {
    Create thread unit test.
} -body {
    unset macports::portinterp_options
    set macports::portinterp_options {a b}

    set res [macports::create_thread]
    if {![string match "tid0x*" $res]} {
	return "FAIL: cannot create thread"
    }
    return "Create thread successful."
} -result "Create thread successful."


# test get_tar_flags


test fetch_port {
    Fetch port unit test.
} -body {
    set portdbpath $pwd/portdbpath
    set macports::portdbpath $portdbpath
    set url "http://packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2"

    if {[macports::fetch_port $url 0] != "${portdbpath}/portdirs/fondu-060102_1.darwin_12.x86_64"} {
	return "FAIL: cannot fetch archive"
    }
    if {![file exists $portdbpath/portdirs/fondu-060102_1.darwin_12.x86_64.tbz2]} {
	return "FAIL: missing archive file"
    }
    if {![file exists $portdbpath/portdirs/+PORTFILE]} {
	return "FAIL: missing +PORTFILE file"
    }
    if {![file exists $portdbpath/portdirs/+DESC]} {
	return "FAIL: missing +DESC file"
    }
    if {![file exists $portdbpath/portdirs/+STATE]} {
	return "FAIL: missing +STATE file"
    }
    if {![file exists $portdbpath/portdirs/opt]} {
	return "FAIL: missing /opt dir"
    }
    return "Fetch port successful."
} -cleanup {
    file delete -force $portdbpath
} -result "Fetch port successful."


test getprotocol {
    Get protocol unit test.
} -body {
    if {[macports::getprotocol http://www.macports.org] != "http"} {
	return "FAIL: wrong protocol"
    }
    return "Get protocol successful."
} -result "Get protocol successful."


test getportdir {
    Get port dir unit test.
} -body {
    set url "http://packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2"
    if {[macports::getportdir $url .] != "${portdbpath}/portdirs/fondu-060102_1.darwin_12.x86_64"} {
	return "FAIL: wrong path"
    }
    return "Get port dir successful."
} -cleanup {
    file delete -force $portdbpath
} -result "Get port dir successful."


test getportresourcepath {
    Get port resource path. Doesn't check for 'file' protocol.
} -body {
    set macports::portdbpath $pwd/portdbpath
    set url "http://packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2"
    set default_path $pwd/portdbpath/sources/rsync.macports.org/release/tarballs/ports/_resources
    set fallback_path $pwd/portdbpath/sources/packages.macports.org/fondu/fondu-060102_1.darwin_12.x86_64.tbz2/_resources

    if {[macports::getportresourcepath $url "" yes] != $default_path} {
	return "FAIL: wrong resource path"
    }
    if {[macports::getportresourcepath $url "" no] != $fallback_path} {
	return "FAIL: wrong fallback path"
    }
    if {[macports::getportresourcepath $url "test" no] != "${fallback_path}/test"} {
	return "FAIL: wrong fallback path with subdir"
    }

    return "Get resource path successful."
} -result "Get resource path successful."


test getdefaultportresourcepath {
    Get default port resource path unit test.
} -body {
    set path test/path
    set macports::sources_default file://$pwd
    if {[macports::getdefaultportresourcepath $path] != "${pwd}/_resources/${path}"} {
	return "FAIL: wrong file res path"
    }
    set macports::sources_default http://$pwd
    set right_path $pwd/portdbpath/sources/Volumes/Other/_resources/test/path
    if {[macports::getdefaultportresourcepath $path] != $right_path} {
	return "FAIL: wrong http res path"
    }
    return "Default res path successful."
} -result "Default res path successful."


test mportopen {
    Mport open unit test.
} -setup {
    set os_platform darwin
    set os.platform darwin
    set macosx_version 10.8
    set os_version 12
    set os_arch i386

    global os_platform

    set macports::portdbpath $pwd/portdbpath
    set macports::portconf $pwd/conf
} -body {
    # set mport [mportopen file://.]
    # puts [ditem_key $mport refcnt]
    # if {[mportopen file://.] != "ditem_1"} {
	# return "FAIL: Portfile not opened"
    # }
    return "Mport open successful."
} -cleanup {
    #mportclose $mport
} -result "Mport open successful."


test mportopen_installed {
    Mport installed unit test.
} -constraints {
    root
} -setup {
    global os_platform os_version os_arch macosx_version pwd
    global version mport portpath portbuildpath

    set os.platform darwin
    set macosx_version 10.8
    set os_version 11
    set os_arch i386
    set os.major 10
    set supported_archs {}
    set configure.build_arch build_arch
    set portarchivetype tgz

    set subport fondu
    set version 3.0
    set create $pwd/create
    set portbuildpath $pwd
    set destpath $pwd/work/destroot
    set portpath $pwd

    file copy -force $pwd/Portfile /tmp/
    set mport [mportopen file://.]

    proc getportbuildpath {id {portname ""}} {
	global portdbpath
	regsub {://} $id {.} port_path
	regsub -all {/} $port_path {_} port_path
	return [file join $portdbpath build $port_path $portname]
    }

    proc getportworkpath_from_buildpath {portbuildpath} {
	return [file join $portbuildpath work]
    }

    proc getportworkpath_from_portdir {portpath {portname ""}} {
	return [getportworkpath_from_buildpath [getportbuildpath $portpath $portname]]
    }

    source $pwd/../../port1.0/portmain.tcl

    # sets up PortInfo array
    if {[eval_variants variations] != 0} {
	mportclose $mport
	error "Error evaluating variants"
    }

    # set $version var
    set workername [ditem_key $mport workername]

    # run destroot
    $workername eval eval_targets destroot

    # portinstall setup
    interp alias {} _cd {} cd
    set macosx_deployment_target $pwd/deploy_target
    file mkdir $pwd/$subport
    file link -symbolic $pwd/$subport/work $pwd/work

    if {[catch {portinstall::install_main}] != 0} {
        return "FAIL: cannot install port"
    }
} -body {
} -cleanup {
    set res [uninstall_main]
    mportclose $mport

    file delete -force $pwd/$subport/work
    file delete -force $pwd/$subport
} -result ""


# test mportclose_installed
# test mporttraverse
# test _mportsearchpath
# test _mportinstalled
# test _mportactive
# test _portnameactive
# test _mportispresent
# test _mporterrorifconflictsinstalled
# test _mportexec
# test mportexec
# test _upgrade_mport_deps
# test _get_registry_archs
# test getsourcepath
# test _source_is_snapshot
# test getportbuildpath
# test getportlogpath
# test getportworkpath_from_buildpath
# test getportworkpath_from_portdir
# test getindex
# test mportsync
# test mportsearch
# test mportlookup
# test mportlistall
# test _mports_load_quickindex
# test mports_generate_quickindex
# test mportinfo
# test mportclose

# test _mportkey
# test mportdepends
# test _mport_supports_archs
# test _mport_archs
# test _active_supports_archs
# test _active_archs
# test _explain_arch_mismatch
# test _mport_has_deptypes
# test _target_needs_deps
# test _deptypes_for_target
# test selfupdate
# test upgrade
# test _upgrade
# test _upgrade_dependencies
# test mportselect
# test gettmpdir
# test arch_runnable
# test revupgrade
# test revupgrade_scanandrebuild
# test path_is_in_prefix
# test revupgrade_handle_special_paths
# test revupgrade_buildgraph
# test get_pingtime
# test set_pingtime
# test get_archive_sites_conf_values


cleanupTests
